PHPer上級者になるために知っておきたいこと

今回は割合と「実務メイン」で失礼をさせていただければと思います。
早速ですが、前回ちらりと出しました「プレースホルダ」について少し細かい話をさせていただければ、と思います。
用語を少し厳密におさらいしておきましょう。
まず「正式なデータが入るまでの臨時のスペースを適切な表記で仮に表現した」SQLを準備しておきます。このように準備されたSQLを「準備された文(プリペアドステートメント)」と呼称します。
また「正式なデータが入るまでの臨時のスペースを適切な表記で仮に表現したもの」を、プレースホルダと呼称します。
ちなみに「プレースホルダ」という呼称自体は、SQLのこの話の他に、「HTML5(placeholder属性)」「PowerPoint」などにも出てくる用語です。確かに「とりあえずの、仮の目印」は便利ですからね。
上述のようなケースにおいて「準備された文」と「バインドされた値」は別々に通信されます。
この「別々に通信される」ことは、SQL-Injection対策としてとても有効になります。
「別々に通信されることが原理的にSQL-Injection対策になる」理由を細かく書くとかなり長くなってしまうのですが、端的には「”SQLのパース処理時”の”本来の意図と異なるパース結果”を誘発することによって悪意あるSQLを発行させるSQL-Injection」に対して「そもそも”準備された文”に”別途通信された値をバインドする”という手間をかけるので、”パース処理の誤謬を誘発させる”ことが原理的に出来ない」ために安全である、という事になります。
…という話は、実は「全てのプリペアドステートメント/プレースホルダ/バインド機構」に当てはまるわけでは、残念なことにありません。
実務的に割とでかいところなので、気をつけておきましょう。
上述のように「通信を分けて」原理的に安全なものを「プリペアドステートメント/プレースホルダ/バインド機構」と呼称するのですが。
実は、別の挙動をするものを、同じように呼称する事があります。
「別の挙動」の場合、以下のような動きをします。
「準備された文」を受け取って、DBインスタンス(プロパティを想起してください)でため込む
値のバインドも、DBインスタンスでため込む
executeなどの「実行」メソッドがcallされた時点で「ライブラリ内で、適切なエスケープ処理をしてSQLを組み立てて」DBサーバと通信をする
一見さほどの問題はないように思われるのですが。このやり方の場合、もし「ライブラリのSQL組み立ての実装で誤りがある」と、最終的にSQL-Injectionが発生する可能性が、可能性としては残されてしまいます。
前者の”原理的に安全な方”を「静的プレースホルダ」、後者の”危険な可能性がある方”を「動的プレースホルダ」と呼称しています。
皆さんも是非、「静的か動的か」までを意識してご利用いただければ、安全性もいや増しに増すと思われます。
ちなみに、一部で「静的プレースホルダは通信を2回するから通信コストが」という話を耳にすることもあるのですが。
天秤の片側に「SQL-Injectionの可能性」を載せますと、やはり「動的プレースホルダにする」という選択肢はなかなかチョイスしにくいモノがあるのではないかと思います。
さてこういった話を展開するのは楽しくもあり有意義でもあり、といった所ではあるのですが、一方で現場でよく耳にするのが「ンなこと言ったって今更できるかい」といった類いのお話でございます。
いわゆる「既存の改修」というやつですね。
次回は「既存の改修」をどうやって進めていくか、というお話しを、上級試験の出題範囲に絡めつつ進めていきます。
おそらくは「オブジェクト」「セキュリティ」「アプリケーションに関するテクニック」あたりを絡めていく感じになるのではないか、と思います。
